<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Welcome</title>
<link href="style.css" rel="stylesheet" type="text/css" />
<link href='http://fonts.googleapis.com/css?family=Open+Sans:400,300,400italic,300italic,600,600italic,700,700italic,800,800italic' rel='stylesheet' type='text/css'>
</head>

<body>
<h1><a name="top" id="top"></a>Displaying your extension</h1>
<p>MMF  applications are displayed in a HTML5 Canvas element. Your extension can draw  itself in this canvas using the HTML5 canvas context.<br />
  MMF has added one level of abstraction to the process, to enable in the future, the  implementation of WebGL accelerated canvas, with the &quot;Renderer&quot;  class.<br />
To display your  extension, you can choose to use the usual context based, HTML5 drawing  routines, or use the &quot;Renderer&quot; class designed specially for future  compatibility.</p>
<p><strong>Drawing your  extension using the HTML5 context.</strong><br />
  If you already  know HTML5 and canvas, you might want to choose this option. Please note that  your extension will not be able to work in WebGL mode when this mode is  implemented in MMF, if the user chooses WebGL as a display option. You should  therefore indicate somewhere in the documentation of your object that it is not  compatible with WebGL rendering.<br />
  The  displayRunObject function of your extension is called with a pointer to the  &ldquo;Renderer&rdquo; class as a first parameter. You can very simply retreive the HTML5  drawing context with the following line :</p>
<div class="code"> displayRunObject:<span class="blue">function(renderer</span>, xDraw, yDraw<span class="blue">)<br />
  {<br />
&nbsp;&nbsp;&nbsp;var  drawingContext=renderer._context;<br />
  <br />
  //  Use &quot;_context&quot; to get the HTML5 context from the renderer<br />
  //  Use the drawingContext variable to draw your object.<br />
  //  Do not forget to offset any coordinate with xDraw and yDraw.<br />
}</span></div>
<p><strong>Drawing your  extension using the Renderer class</strong><br />
  The Renderer  class encapsulates a classic, context based renderer, and a future WebGL renderer. The drawing functions are designed to cope with both, and are therefore different from normal HTML5 context functions.<br />
  All the  functions ask for two extra parameters, inkEffect and inkEffectParam. See the  next chapter for more information about them. If you do not plan to use ink  effects, just trasmit 0, 0 as parameters.<br />
All the &quot;color&quot; parameters are coded as a number (hexadecimal triplet), and not as a string as in normal HTML5 context drawing. For example, the number 0xFF0000 will draw a  bright red on the screen.</p>
<h4>renderLine(xA, yA, xB, yB, color, thickness, inkEffect, inkEffectParam)</h4>
<blockquote>
  <p>Draws a line between the points (xA, yA) and (xB, yB). The thickness  parameter indicates the thickness of the line, in pixels. A value of 1 will  draw the thinnest possible line.
    </h4>
  </p>
</blockquote>
<h4>renderRect(x, y, width, height, color, thickness, inkEffect, inkEffectParam)</h4>
<blockquote>
  <p>Draws a rectangle of the given color. As for the previous function, the thickness parameter indicates the thickness of the line used to draw the  rectangle.
    </h4>
  </p>
</blockquote>
<h4>renderEllipse(x, y, width, height, thickness, color, inkEffect, inkEffectParam)</h4>
<blockquote>
  <p>Draws an ellipse of the given color. Same remark for the  &quot;thickness&quot; parameter.</h4>
  </p>
</blockquote>
<h4>renderSolidColor(x, y, width, height, color, inkEffect, inkEffectParam)</h4>
<blockquote>
  <p>Draws rectangle  filled with the given color.</p>
</blockquote>
<h4>renderSolidColorEllipse(x, y, width, height, color, inkEffect, inkEffectParam)</h4>
<blockquote>
  <p>Draws an  ellipse filled with the given color.</p>
</blockquote>
<h4>renderGradient(x, y, width, height, color1, color2, vertical, inkEffect, inkEffectParam)</h4>
<blockquote>
  <p>Draws a  rectangle filled with a linear color gradient, ranging from color1 to color2  (from left to right or top to bottom). The &quot;vertical&quot; parameter is a  boolean value: if false, the function draws a horizontal gradient, if true it draws a vertical gradient.</p>
</blockquote>
<h4>renderGradientEllipse(x, y, w, h, color1, color2, vertical, inkEffect, inkEffectParam)</h4>
<blockquote>
  <p>Draws an ellipse filled with a gradient of color, ranging from color1 to  color2. The same remarks as the previous function apply to this function.</p>
</blockquote>
<h4>renderPattern(image, x, y, width, height, inkEffect, inkEffectParam)</h4>
<blockquote>
  <p>Draws a rectangle filled by the repetition of one image. The  &quot;image&quot; parameter must point to a &quot;CImage&quot; object (and NOT  a HTML5 Image object).</p>
</blockquote>
<h4>renderPatternEllipse:  function(image, x, y, w, h, inkEffect,  inkEffectParam)</h4>
<blockquote>
  <p>Draw an ellipse filled by the repetition of one image. As for the  previous function, the &quot;image&quot; parameter points to a  &quot;CImage&quot; object.</p>
  </p>
</blockquote>
<h4>renderImage(image, x, y, angle, scaleX, scaleY, inkEffect, inkEffectParam)</h4>
  <blockquote>
    <p>Draws a CImage onto the screen. Such a CImage can be obtained with the  &quot;getImage&quot; function callback of the CExtension class.<br />
      The angle parameter contains the rotation angle of the image around it's  hot spot (defined in the CImage class). The angle is expressed in degrees, from  0 to 360. The scaleX and scaleY parameters indicate the horizontal and vertical  zoom factor to apply to the image. A value of 1.0 indicates no zoom, 0.5 will  halve the image, 2 will double its size.</p>
    </p>
  </blockquote>
<h4>renderSimpleImage(image, x, y, width, height, inkEffect, inkEffectParam)</h4>
<blockquote>
  <p>Draws a simple HTML5 image on the screen. The image parameter can be an
&quot;Image&quot; class or a &quot;Canvas&quot; class. Width and height  indicate the width and height of the drawn image. To display the image at its  normal size, just transmit &quot;image.width&quot; and  &quot;image.height&quot;.</p>
</blockquote>
<br />
<h1><a name="CTextSurface" id="CTextSurface"></a>The CTextSurface object</h1>
<p>The CTextSurface objject caches the drawing of a text in a hidden  surface to accelerate the rendering process. Instead of being physically drawn  on the screen, the text is first drawn in a hidden canvas, and only the canvas  is drawn on the screen.<br />
  The object is also directly compatible with the renderer class, assuring  your application will work in the future.<br />
To use this object, simple create it with a &quot;<strong>new</strong>&quot;  statement, and call the &quot;<strong>setText</strong>&quot; function to draw the text in  the hidden canvas. Then call the &quot;<strong>draw</strong>&quot; function to actually  draw the text onto the screen.</p>
<h4>CTextSurface(application, width, height)</h4>
<blockquote>
  <p>Creates a new text surface of the given width and height. The first  parameter is a pointer to the application object (CRunApp). You can find this  variable in : <strong>this.rh.rhApp</strong></p>
</blockquote>
<h4>measureText(text, font)</h4>
<blockquote>
  <p>Returns the width of the text drawn with the given font.The text  parameter contains the string of text to test, and the font parameter contains  a pointer to either a CFont object (use internally in MMF), or a CFontInto  object (that you can use in your extension). Using this function ensures you that  the object will be compatible with future renderer. Ou may have to create a  small dummy text surface just to measure some strings.</p>
</blockquote>
<h4>setText(text, flags, rectangle, font, color)</h4>
<blockquote>
  <p>Draws the text in the internal surface, using the given flags,  rectangle, font and color.</p>
  <p><strong>- text :</strong> the text to draw. The text can contain cariage  returns and be multiline.<br />
    <strong>- flags :</strong> indicate how to justify the text.</p>
  <ul>
    <li>CServices.DT_LEFT : the text is aligned on the left</li>
    <li>CServices.DT_CENTER : the text is centered on the  given rectangle</li>
    <li>CSerivces.DT_RIGHT : the text is aligned on the right  of the rectangle</li>
    <li>CServices.DT_TOP : the text is displayed on the top of  the rectangle</li>
    <li>CServices.DT_VCENTER : the text is centered vertically  in the rectangle</li>
    <li>CServices.DT_BOTTOM : the text is aligned on the  bottom of the rectangle</li>
    <li>CServices.DT_MULTILINE : you must use this flag if  your text contains cariage returns and if you want them to be taken into  account</li>
  </ul>
  <p><strong>- rectangle :</strong> a CRect object  that contains the dimension of the rectangle used for drawing the text. The  size of this rectangle can be different from the size of the CTextSurface  object. This parameter can be null, for example when the text is displayed on  the top and left. Please note that if the size of the drawing surface is  smaller than the size of the rectangle, the text will be truncated on the right  and bottom.<br />
    <strong>- font :</strong> a CFontInfo object  containing information on the font to use. Can also be a CFont object.<br />
  <strong>- color :</strong> an hexadecimal  color value</p>
</blockquote>
<h4>resize(newWidth, newHeight)</h4>
<blockquote>
  <p>Changes the size of the internal drawing surface of the object.</p>
</blockquote>
<h4>draw(renderer, x, y, inkEffect, inkEffectParam)</h4>
<blockquote>
	<p>Draws the text surface in the current display.</p>
  <blockquote>
      <p><strong>- renderer : </strong>the renderer  object where the display takes place<br />
        <strong>- x :</strong> the horizontal position  where to draw the surface<br />
        <strong>- y :</strong> the vertical position  where to draw the surface<br />
        <strong>- inkEffect : </strong>the effect to  use when displaying the surface (see later)<br />
        <strong>- inkEffectParam :</strong> see later
      </p>
  </blockquote>
</blockquote>
<br />
<h1><a name="inkEffects" id="inkEffects"></a>Ink Effects</h1>
<p>All the renderer-based drawing functions ask for two extra parameters,  &quot;inkEffect&quot; and &quot;inkEffectParam&quot;. These parameters  correspond to the inkEffects available in MMF. If you choose a renderer-based  display, you can very simply indicate to use semi-transparency or a drawing  effect.</p>
<p>The &quot;inkEffect&quot; parameter indicates what effect to use. It  contains a coded value with the alpha-transparency, the drawing mode, and an  eventual RGB coefficient. This value is coded as followed:</p>
<h3>inkEffect &amp; CRSpr.BOP_MASK</h3>
<p>Where &quot;CRSpr.BOP_MASK&quot; is a hexadecimal value, equal to  0x00000FFF<br />
  The value contained in this part of the inkEffect parameter can take the  following values:<br />
  <strong><br />
  CRSpr.BOP_ADD :</strong> indicates to use the ADD drawing  algorythm. The pixel drawn on the screen is equal to the value of the source  pixel added to the destination pixel.<br />
  <strong><br />
  CRSpr.BOP_XOR :</strong> indicates to use the XOR drawing  algorythm. The pixel drawn on the screen is equal to the value of the source  pixel combined by a logical XOR operation to the value of the destination  pixel.<br />
  <br />
  <strong>CRSpr.BOP_BLEND :</strong> indicates a semi-transparent  drawing. In this case &quot;inkEffectParam&quot; contains the value of the  transparency, from 0 (opaque) to 128 (fully transparent).<br />
  Any other value : the destination pixel is replaced by  the source pixel when it is not tranparent.</h3>
</p>
<p>If the bit <strong>CRSpr.BOP_RGBAFILTER</strong> is set, the  &quot;inkEffectParam&quot; parameter contains extra data to set both the  transparency and the RGB Coefficient. Please note that the RGB coefficient is  not implemented in the context-based renderer, but will be implemented in the  future WebGL renderer.<br />
  <strong>(effectParam&gt;&gt;16)&amp;0xFF :</strong> the red value  of the RGB coefficient<br />
  <strong>(effectParam&gt;&gt;8)&amp;0xFF : </strong>the green  value of the RGB coefficient<br />
  <strong>effectParam&amp;0xFF :</strong> the blue value of the RGB coefficient<br />
  <strong>(effectParam&gt;&gt;24)&amp;0xFF :</strong> the value  semi-transparency, from 0 (transparent) to 255 (opaque).<br />
The CRSpr.BOP_RGBAFILTER variable has a value of 0x1000</p>
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
</body>
</html>